<?php
/**
 * Author: Damian Schwyrz <mail@damianschwyrz.de>
 * URL: https://www.damianschwyrz.de
 * Copyright (c) 2018.
 */

namespace App\Console\Commands;

use App\AdminNotice;
use App\Target;
use Illuminate\Console\Command;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\File;
use Symfony\Component\Process\Process;

/**
 * Class Dirsearch
 * @package App\Console\Commands
 */
class Dirsearch extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'dirsearch:scan
        {--target=0 : Target ID in database} 
        {--url=0 : Target URL}
        {--threads=4 : Max threads to use} 
        {--extensions=php,sql,aspx,bak,bkp : Extensions used when placeholder is found} 
        {--ignore-status=403,404,401,500,503,502,400,501,520,999 : HTTP Status to ignore} 
        {--wordlist=quick.txt : Which wordlist to use (in folder wordlists/filesdirs}
        {--recursive : Recursive scan in found folders} 
        {--random-useragents : Use random us for requests}
    ';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Start a scan on the target.';

    /**
     * @var \App\Target
     */
    protected $target;

    /**
     * @var string
     */
    protected $cmd = "";

    /**
     * Create a new command instance.
     *
     * @return void
     */
    public function __construct()
    {
        parent::__construct();

    }

    /**
     * Execute the console command.
     *
     * @return mixed
     */
    public function handle()
    {

        list($targetId, $targetUrl, $threads, $recursiveSearch, $wordlist, $randomUserAgents, $extensions, $ignoreStatus) = $this->getArguments();

        $this->validateArguments($targetId, $targetUrl, $threads, $wordlist);

        $this->target = Target::findOrFail($targetId);

        list($outputFile, $outputPath) = $this->makeOutputFileAndPath($targetUrl, $targetId);

        $this->cmd = $this->createCommand(
            $targetUrl,
            $extensions,
            $ignoreStatus,
            $threads,
            $wordlist,
            $randomUserAgents,
            $recursiveSearch,
            $outputPath
        );

        $this->line($this->cmd);

        AdminNotice::create([
            'type'    => 'success',
            'context' => "dirsearch:scan",
            'message' => "Execution started",
            'cmd'     => $this->cmd,
        ]);

        $this->executeCmd($this->cmd);

        $this->checkIfReportWasCreated($outputPath);

        $jsonContent = $this->getReport($outputPath);

        $urlUsedInScan = $this->getUrlUsedFinallyByDirSearch($jsonContent);

        $jsonContent = $this->flattenReportArray($jsonContent);
        $jsonContent = $this->filterIfALotRequestsReturn200($jsonContent);

        $text = $this->createReportForFrontend($jsonContent, $urlUsedInScan, $outputFile);
        $this->saveReportToDB($text);

        $message = "Process finished, report saved to file and database.";

        $this->info($message);

        AdminNotice::create([
            'type'    => 'success',
            'context' => "dirsearch:scan",
            'message' => $message,
            'cmd'     => $this->cmd,
        ]);

    }

    /**
     * @return array
     */
    protected function getArguments(): array
    {
        $targetId = $this->option('target');
        $targetUrl = trim($this->option('url'));
        $threads = $this->option('threads');
        $recursiveSearch = $this->option('recursive');
        $wordlist = base_path("toolset/wordlists/filesdirs/" . $this->option('wordlist'));
        $randomUserAgents = $this->option('random-useragents');
        $extensions = $this->option('extensions');
        $ignoreStatus = $this->option('ignore-status');

        return [
            $targetId,
            $targetUrl,
            $threads,
            $recursiveSearch,
            $wordlist,
            $randomUserAgents,
            $extensions,
            $ignoreStatus,
        ];
    }

    /**
     * @param int    $targetId
     * @param string $targetUrl
     * @param int    $threads
     * @param string $wordlist
     */
    protected function validateArguments(int $targetId, string $targetUrl, int $threads, string $wordlist)
    {
        $message = "";
        $abort = false;

        if ($targetUrl == "") {
            $abort = true;
            $message = "TargetURL not set!";
        }
        if ($targetId <= 0) {
            $abort = true;
            $message = "targetID has to be bigger than 0";
        }

        if ($threads <= 0) {
            $abort = true;
            $message = "threads has to be bigger than 0";
        }

        if (!File::exists($wordlist)) {
            $abort = true;
            $message = "wordlist does not exist";
        }

        if ($abort) {
            $this->error($message);

            AdminNotice::create([
                'type'    => 'error',
                'context' => "dirsearch:scan",
                'message' => $message,
                'cmd'     => $this->cmd,
            ]);

            exit();

        }

    }

    /**
     * @param $targetUrl
     * @param $targetId
     *
     * @return array
     */
    protected function makeOutputFileAndPath($targetUrl, $targetId): array
    {
        $outputFile = str_slug($targetUrl) . "-" . $targetId . ".json";
        $outputPath = storage_path("app/public/dirscan/" . $outputFile);

        return [$outputFile, $outputPath];
    }

    /**
     * @param string $targetUrl
     * @param string $extensions
     * @param string $ignoreStatus
     * @param int    $threads
     * @param string $wordlist
     * @param string $randomUserAgents
     * @param string $recursiveSearch
     * @param string $outputPath
     *
     * @return array
     */
    protected function createCommand(
        string $targetUrl,
        string $extensions,
        string $ignoreStatus,
        int $threads,
        string $wordlist,
        string $randomUserAgents,
        string $recursiveSearch,
        string $outputPath
    ): string {
        $cmd = [];

        $cmd[] = config('toolset.bin.python3');
        $cmd[] = config("toolset.path.dirsearch");
        $cmd[] = '-u ' . trim($targetUrl);
        $cmd[] = '-e ' . $extensions;
        $cmd[] = '-x ' . $ignoreStatus;
        $cmd[] = '-t ' . $threads;
        $cmd[] = '-w ' . $wordlist;
        $cmd[] = '--suppress-empty';
        $cmd[] = '-l';
        $cmd[] = '-F';

        if ($randomUserAgents) {
            $cmd[] = '--random-agents';
        }

        if ($recursiveSearch) {
            $cmd[] = '-r';
        }

        $cmd[] = '--json-report="' . $outputPath . '"';
        $finaleCommand = implode(" ", $cmd);

        return $finaleCommand;
    }

    /**
     * @param string $finaleCommand
     */
    protected function executeCmd(string $finaleCommand)
    {
        $process = new Process($finaleCommand);

        $process->setTimeout(
            config("toolset.dirsearch.timeout")
        );

        $process->start();

        $process->wait(function ($type, $buffer) {
            if (Process::ERR === $type) {
                $this->error($buffer);
            } else {
                $this->line($buffer);
            }
        });
    }

    /**
     * @param string $outputPath
     */
    protected function checkIfReportWasCreated(string $outputPath): void
    {
        if (!File::exists($outputPath)) {

            $message = "Failed importing report... no report found";

            $this->warn($message);

            AdminNotice::create([
                'type'    => 'warning',
                'context' => "dirsearch:scan",
                'message' => $message,
                'cmd'     => $this->cmd,
            ]);

            exit();
        }
    }

    /**
     * @param string $outputPath
     *
     * @return \Illuminate\Support\Collection|mixed
     */
    protected function getReport(string $outputPath): Collection
    {
        $reportContent = File::get($outputPath);
        $jsonContent = \json_decode($reportContent);
        $jsonContent = collect($jsonContent);

        return $jsonContent;
    }

    /**
     * @param \Illuminate\Support\Collection $jsonContent
     *
     * @return string
     */
    protected function getUrlUsedFinallyByDirSearch(Collection $jsonContent): string
    {
        $urlUsedInScan = $jsonContent->keys()->first();

        return $urlUsedInScan;
    }

    /**
     * @param \Illuminate\Support\Collection $jsonContent
     *
     * @return \Illuminate\Support\Collection|static
     */
    protected function flattenReportArray(Collection $jsonContent): Collection
    {
        $jsonContent = $jsonContent->flatten();

        return $jsonContent;
    }

    /**
     * Dirsearch is a nice tool, but sometimes the target returns nearly everything as 301 or 200. Those elements have
     * something incommon... the content size is everywhere the same. Thats why we calculate the most common
     * content-size value and remove every element with this content-size IF 50% of the total elements have this
     * content-size. This applies only when there are more than 20 elements.
     *
     * @param \Illuminate\Support\Collection $jsonContent
     *
     * @return \Illuminate\Support\Collection|static
     */
    protected function filterIfALotRequestsReturn200(Collection $jsonContent): Collection
    {

        $elementCount = $jsonContent->count();

        if ($elementCount <= 20) {
            return $jsonContent;
        }

        $criticalContentCount = (int)$elementCount * 0.5;
        $contentSizes = $jsonContent->pluck("content-length");
        $contentSizesOccurence = array_count_values($contentSizes->toArray());

        arsort($contentSizesOccurence);

        $mostFrequentContentSize = reset($contentSizesOccurence);
        $mostFrequentContentSizeValue = array_keys($contentSizesOccurence)[0];

        if ($mostFrequentContentSize >= $criticalContentCount) {
            $jsonContent = $jsonContent->filter(function ($element) use ($mostFrequentContentSizeValue) {
                return ($element->{"content-length"} != $mostFrequentContentSizeValue);
            });
        }

        return $jsonContent;
    }

    /**
     * @param \Illuminate\Support\Collection $jsonContent
     * @param string                         $urlUsedInScan
     * @param string                         $outputFile
     *
     * @return string
     */
    protected function createReportForFrontend(
        Collection $jsonContent,
        string $urlUsedInScan,
        string $outputFile
    ): string {
        $text = [];
        $text[] = "Full Report: " . asset("storage/dirscan/" . $outputFile) . "\n\n";


        foreach ($jsonContent as $element) {

            if (is_null($element->redirect)) {
                $element->redirect = "-";
            }


            $text[] = $urlUsedInScan . $element->path . "    " . $element->status . "    " . $element->redirect . "    " . $element->{"content-length"};
        }

        return implode("\n", $text);
    }

    /**
     * @param string $report
     */
    protected function saveReportToDB(string $report): void
    {
        DB::reconnect();

        $this->target->files_dirs_found = $report;
        $this->target->save();
    }

    /**
     * @return array
     */
    protected function createTargetUrlOptions(): array
    {
        $targetOptions = [
            $this->target->subdomain,
            "https://" . $this->target->subdomain . "/",
            "http://" . $this->target->subdomain . "/",
        ];

        if (!is_null($this->target->final_redirect_url)) {
            $targetOptions[] = $this->target->final_redirect_url;
        }

        $targetOptions = array_unique($targetOptions);

        return $targetOptions;
    }

    /**
     *
     */
}
