<?php
/**
 * Author: Damian Schwyrz <mail@damianschwyrz.de>
 * URL: https://www.damianschwyrz.de
 * Copyright (c) 2018.
 */

namespace App\System;

/**
 * Class TSPOutputParser
 * @package App\System
 */
class TSPOutputParser
{

    protected $output = [];

    /**
     * We want to split the raw "tsp" output into parts to make use of them (e.g. the ID within TSP) in the frontend.
     * This is the "best" way I have found so far. If you read this and have better idea, maybe some regexpression within
     * ubtuntu... hit me!
     *
     * TSPOutputParser constructor.
     *
     * @param string $rawOutput
     */
    public function __construct(string $rawOutput)
    {

        $outputLines = $this->splitInLines($rawOutput);

        $lines = $this->splitLineByEmptySpace($outputLines);


        $this->output[] = $this->makeHeader($lines);

        $lineIterator = 0;

        foreach ($lines as $line) {

            $lineIterator += 1;

            if ($this->isFirstLine($lineIterator)) {
                continue;
            }

            if ($this->toFewLineElements($line)) {
                continue;
            }

            $tempLine = $this->resetFirst5Columns($line);

            $this->output[] = $this->composeDataArrayBasedOnState($line, $tempLine);

        }


    }

    /**
     * Split Multiline textoutput from ubuntu bash into an array of single lines.
     *
     * @param string $rawOutput
     *
     * @return array|false|string[]
     */
    protected function splitInLines(string $rawOutput)
    {
        $outputLines = preg_split("/\r\n|\n|\r/", $rawOutput);

        return $outputLines;
    }

    /**
     * Split every line into parts seperated by whitespace.
     *
     * @param array $outputLines
     *
     * @return array
     */
    protected function splitLineByEmptySpace(array $outputLines): array
    {
        $lines = [];

        foreach ($outputLines as $line) {
            $lines[] = preg_split("/([\s]+)/", $line);
        }

        return $lines;
    }

    /**
     * The first line/array element is always the tsp header.
     *
     * @param array $lines
     *
     * @return array
     */
    protected function makeHeader(array $lines): array
    {
        return [
            'ID'      => $lines[0][0],
            'State'   => $lines[0][1],
            'Output'  => $lines[0][2],
            'E-Level' => $lines[0][3],
            'Times'   => $lines[0][4],
            'Command' => $lines[0][5],
        ];
    }

    /**
     * @param integer $lineIterator
     *
     * @return bool
     */
    protected function isFirstLine(int $lineIterator): bool
    {
        return $lineIterator == 1;
    }

    /**
     * @param array $line
     *
     * @return bool
     */
    protected function toFewLineElements(array $line): bool
    {
        return count($line) < 2;
    }

    /**
     * @param array $line
     *
     * @return array
     */
    protected function resetFirst5Columns(array $line): array
    {
        $tempLine = $line;

        unset($tempLine[0]);
        unset($tempLine[1]);
        unset($tempLine[2]);
        unset($tempLine[3]);
        unset($tempLine[4]);

        return $tempLine;
    }

    /**
     * @param array $line
     * @param array $tempLine
     *
     * @return array
     */
    protected function composeDataArrayBasedOnState(array $line, array $tempLine): array
    {
        $data = [
            'ID'     => $line[0],
            'State'  => $line[1],
            'Output' => $line[2],
        ];

        if ($line[1] == "running" || $line[1] == "queued") {
            $data["E-Level"] = "";
            $data["Times"] = "";
            $data["Command"] = implode(" ", array_merge([$line[3], $line[4]], $tempLine));
        } else {
            $data['E-Level'] = $line[3];
            $data['Times'] = $line[4];
            $data['Command'] = implode(" ", $tempLine);
        }

        return $data;
    }

    /**
     * @return mixed
     */
    public function getResult()
    {
        return json_decode(json_encode($this->output));
    }


}