<?php
/**
 * Author: Damian Schwyrz <mail@damianschwyrz.de>
 * URL: https://www.damianschwyrz.de
 * Copyright (c) 2018.
 */

/**
 * Created by PhpStorm.
 * User: damian
 * Date: 25.02.18
 * Time: 11:20
 */

namespace App\Task;


use App\System\Crawler;

class CrawlUrl
{
    private $url;

    private $http_status;
    private $final_redirect_url;
    private $http_response_header;
    private $response;

    public function __construct($url)
    {
        $this->url = $url;
    }


    public function start()
    {
        $crawler = new Crawler();
        $crawler->crawl($this->url);
        $this->response = $crawler->response;
        $this->processCrawlersResponse($crawler);
    }

    /**
     * @param $crawler
     */
    protected function processCrawlersResponse($crawler): void
    {
        /**
         * If failed, host could not be resolved, time out...
         */
        if ($this->requestFailed()) {

            $this->setFailedResponse();

        } else {

            $this->processSuccesfulRequest($crawler);
        }
    }

    /**
     * @return bool
     */
    protected function requestFailed(): bool
    {
        return is_array($this->response) && $this->response['status'] === false;
    }

    /**
     *
     */
    protected function setFailedResponse(): void
    {
        $this->http_status = $this->response['code'];
        $this->final_redirect_url = null;
        $this->http_response_header = $this->response['message'];
    }

    /**
     * @param $crawler
     */
    protected function processSuccesfulRequest($crawler): void
    {
        $newHttpStatus = $this->response->getStatusCode();
        $lastRedirectedUrl = null;

        $headers = $crawler->response->getHeaders();

        if ($this->redirectStatusHistoryFound($headers)) {
            $newHttpStatus = end($headers['X-Guzzle-Redirect-Status-History']);
        }

        if ($this->redirectHistoryNotEmpty($headers)) {
            $lastRedirectedUrl = end($headers['X-Guzzle-Redirect-History']) ?? null;
        }

        $headerContent = $this->concatenateHttpResponseHeaders($headers);

        /**
         * This is special - if http is redirected to a valid url (200, 30x, ...) we want a simple 200 answer...
         */
        if ($this->aRedirectWasFound($newHttpStatus, $lastRedirectedUrl)) {
            $newHttpStatus = 200;
        }

        $this->setHttpResponseData($newHttpStatus, $lastRedirectedUrl, $headerContent);
    }

    /**
     * @param $headers
     *
     * @return bool
     */
    protected function redirectStatusHistoryFound($headers): bool
    {
        return isset($headers['X-Guzzle-Redirect-Status-History']);
    }

    /**
     * @param $headers
     *
     * @return bool
     */
    protected function redirectHistoryNotEmpty($headers): bool
    {
        return isset($headers['X-Guzzle-Redirect-History']);
    }

    /**
     * @param $headers
     *
     * @return array
     */
    protected function concatenateHttpResponseHeaders($headers): array
    {
        $headerContent = [];

        foreach ($headers as $key => $value) {
            $headerContent[] = $key . ": " . implode(";", $value);
        }

        return $headerContent;
    }

    /**
     * @param $newHttpStatus
     * @param $lastRedirectedUrl
     *
     * @return bool
     */
    protected function aRedirectWasFound($newHttpStatus, $lastRedirectedUrl): bool
    {
        return $newHttpStatus < 305 and $lastRedirectedUrl !== "";
    }

    /**
     * @param $newHttpStatus
     * @param $lastRedirectedUrl
     * @param $headerContent
     */
    protected function setHttpResponseData($newHttpStatus, $lastRedirectedUrl, $headerContent): void
    {
        $this->http_status = $newHttpStatus;
        $this->final_redirect_url = $lastRedirectedUrl;
        $this->http_response_header = implode("\n", $headerContent);
    }

    /**
     * @return array
     */
    public function getResponse()
    {
        return [
            'http_status'          => $this->http_status,
            'final_redirect_url'   => $this->final_redirect_url,
            'http_response_header' => $this->http_response_header,
        ];
    }
}